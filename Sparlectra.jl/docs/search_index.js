var documenterSearchIndex = {"docs":
[{"location":"networks.html#Netowrks-Module","page":"Netowrks Module","title":"Netowrks Module","text":"","category":"section"},{"location":"networks.html","page":"Netowrks Module","title":"Netowrks Module","text":"The Net module provides functionality for creating and manipulating power system network models in Julia. It includes features for defining buses, branches, transformers, prosumers, and shunts, as well as methods for running power flow analysis.","category":"page"},{"location":"networks.html","page":"Netowrks Module","title":"Netowrks Module","text":"# Import the Net module\n  using Sparlectra\n  using BenchmarkTools\n  # Create a network\n  # Slack bus B1 at 220 kV with 1.0 pu voltage and 0.0 pu angle\n  # PQ bus B2 at 220 kV with 1.0 pu voltage and 0.0 pu angle\n  # PQ bus B3 at 22 kV with 1.0 pu voltage and 0.0 pu angle\n  # Shunt at bus B3 with 0.0 kW and 150.0 kVar\n  # AC line from bus B1 to B2 at 220 kV with 100 km length, 0.0653 ohm/km resistance, 0.398 ohm/km reactance, 9.08 nF/km capacitance, and 0.0 power factor\n  # 2W transformer from bus B2 to B3 with 1000 MVA rating, 13.0% voltage ratio, 0.28% resistance, 20.0 kW power factor, and 0.06% no-load current\n  # Energy consumer at bus B3 with 285.0 kW and 200.0 kVar\n  # Synchronous machine at bus B1 with 1.02 pu voltage and 0.0 pu angle\n  #\n  # G->1* ----L---- 2 --T-- 3->L\n  #                 x\n  #   \n  net = Net(name = \"testnet\", baseMVA = 100.0)\n  addBus!(net = net, busName = \"B1\", busType = \"Slack\", vn_kV = 220.0, vm_pu = 1.0, va_deg = 0.0)\n  addBus!(net = net, busName = \"B2\", busType = \"PQ\", vn_kV = 220.0, vm_pu = 1.0, va_deg = 0.0)\n  addBus!(net = net, busName = \"B3\", busType = \"PQ\", vn_kV = 22.0, vm_pu = 1.0, va_deg = 0.0)\n  addShunt!(net = net, busName = \"B3\", pShunt = 0.0, qShunt = 150.0)\n  addACLine!(net = net, fromBus = \"B1\", toBus = \"B2\", length = 100.0, r = 0.0653, x = 0.398, c_nf_per_km = 9.08, tanδ = 0.0)\n  add2WTrafo!(net = net, fromBus = \"B2\", toBus = \"B3\", sn_mva = 1000.0, vk_percent = 13.0, vkr_percent = 0.28, pfe_kw = 20.0, i0_percent = 0.06)\n  addProsumer!(net = net, busName = \"B3\", type = \"ENERGYCONSUMER\", p = 285.0, q = 200.0)\n  addProsumer!(net = net, busName = \"B1\", type = \"SYNCHRONOUSMACHINE\", referencePri = \"B1\", vm_pu = 1.02, va_deg = 0.0)\n\n  # Run power flow\n  tol = 1e-6\n  maxIte = 10  \n  etime = @elapsed begin\n    ite, erg = runpf!(net, maxIte, tol, 0)\n  end\n  if erg != 0\n    @warn \"Power flow did not converge\"        \n  else\n    calcNetLosses!(net)\n    printACPFlowResults(net, etime, ite, tol)\n  end\n  ","category":"page"},{"location":"networks.html","page":"Netowrks Module","title":"Netowrks Module","text":"  Modules = [Sparlectra]   \n  Pages = [\"network.jl\"]\n  Order = [:type, :function]","category":"page"},{"location":"networks.html#Sparlectra.Net","page":"Netowrks Module","title":"Sparlectra.Net","text":"Net: Represents an electrical network.\n\nFields:\n\nname::String: Name of the network.\nbaseMVA::Float64: Base MVA of the network.\nslackVec::Vector{Int}: Vector containing indices of slack buses.\nvmin_pu::Float64: Minimum voltage limit in per unit.\nvmax_pu::Float64: Maximum voltage limit in per unit.\nnodeVec::Vector{Node}: Vector containing nodes in the network.\nlinesAC::Vector{ACLineSegment}: Vector containing AC line segments.\ntrafos::Vector{PowerTransformer}: Vector containing power transformers.\nbranchVec::Vector{Branch}: Vector containing branches in the network.\nprosumpsVec::Vector{ProSumer}: Vector containing prosumers in the network.\nshuntVec::Vector{Shunt}: Vector containing shunts in the network.\nbusDict::Dict{String,Int}: Dictionary mapping bus names to indices.\nbusOrigIdxDict::Dict{Int,Int}: Dictionary mapping current bus indices to original indices.\n`branchDict::Dict{Tuple{Int, Int},Int} : Dictionary mapping branch tuples to indices.\ntotalLosses::Vector{Tuple{Float64,Float64}}: Vector containing tuples of total power losses.\n_locked::Bool: Boolean indicating if the network is locked.\n\nConstructors:\n\nNet(name::String, baseMVA::Float64, vmin_pu::Float64 = 0.9, vmax_pu::Float64 = 1.1): Creates a new Net object with the given name, base MVA, and optional voltage limits.\n\nFunctions:\n\naddBus!(; net::Net, ...): Adds a bus to the network.\naddShunt!(; net::Net, ...): Adds a shunt to the network.\naddBranch!(; net::Net, ...): Adds a branch to the network.\naddACLine!(; net::Net, ...): Adds an AC line segment to the network.\naddPIModellTrafo!(; net::Net, ...): Adds a transformer with PI model to the network.\nadd2WTrafo!(; net::Net, ...): Adds a two-winding transformer to the network.\naddProsumer!(; net::Net, ...): Adds a prosumer to the network.\nvalidate(; net::Net): Validates the network.\nget_bus_vn_kV(; net::Net, busName::String): Gets the voltage level of a bus by name.\nget_vn_kV(; net::Net, busIdx::Int): Gets the voltage level of a bus by index.\ngetBusType(; net::Net, busName::String): Gets the type of a bus by name.\nlockNet!(; net::Net, locked::Bool): Locks or unlocks the network.\nsetBranchStatus!(; net::Net, branchIdx::Int, status::Int): Sets the status of a branch.\nsetTotalLosses!(; net::Net, pLosses::Float64, qLosses::Float64): Sets the total losses of the network.\ngetTotalLosses(; net::Net): Gets the total losses of the network.\n\n\n\n\n\n","category":"type"},{"location":"networks.html#Sparlectra.add2WTrafo!-Tuple{}","page":"Netowrks Module","title":"Sparlectra.add2WTrafo!","text":"Add a two-winding transformer to the network.\n\nArguments\n\nnet::Net: The network to which the transformer will be added.\nfromBus::String: The name of the bus where the transformer originates.\ntoBus::String: The name of the bus where the transformer terminates.\nsn_mva::Float64: Rated power of the transformer.\nvk_percent::Float64: Voltage regulation percent of the transformer.\nvkr_percent::Float64: Voltage regulation percent of the transformer.\npfe_kw::Float64: Iron loss of the transformer.\ni0_percent::Float64: No-load current percent of the transformer.\nstatus::Int: The status of the transformer. Default is 1.\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.addACLine!-Tuple{}","page":"Netowrks Module","title":"Sparlectra.addACLine!","text":"addACLine!: Adds an AC line segment to the network.\n\nParameters:\n\nnet::Net: Network object.\nfromBus::String: Name of the \"from\" bus.\ntoBus::String: Name of the \"to\" bus.\nlength::Float64: Length of the line segment.\nr::Float64: Resistance of the line segment.\nx::Float64: Reactance of the line segment.\nb::Union{Nothing,Float64} = nothing: Susceptance of the line segment (default is nothing).\nc_nf_per_km::Union{Nothing,Float64} = nothing: Capacitance of the line segment in nF/km (default is nothing).\ntanδ::Union{Nothing,Float64} = nothing: Tangent of the loss angle (default is nothing).\nratedS::Union{Nothing, Float64}= nothing: Rated power of the line segment in MVA (default is nothing).\nstatus::Int = 1: Status of the line segment (default is 1).\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.addBranch!-Tuple{}","page":"Netowrks Module","title":"Sparlectra.addBranch!","text":"addBranch!: Adds a branch to the network.\n\nParameters:\n\nnet::Net: Network object.\nfrom::Int: Index of the \"from\" bus.\nto::Int: Index of the \"to\" bus.\nbranch::AbstractBranch: Branch object to add.\nstatus::Int = 1: Status of the branch (default is 1).\nratio::Union{Nothing,Float64} = nothing: Ratio of the branch (default is nothing).\nside::Union{Nothing,Int} = nothing: Side of the branch (default is nothing).\nvn_kV::Union{Nothing,Float64} = nothing: Nominal voltage of the branch in kV (default is nothing).\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.addBus!-Tuple{}","page":"Netowrks Module","title":"Sparlectra.addBus!","text":"addBus!: Adds a bus to the network.\n\nParameters:\n\nnet::Net: Network object.\nbusName::String: Name of the bus.\nbusType::String: Type of the bus (e.g., \"Slack\", \"PQ\", \"PV\").\nvn_kV::Float64: Nominal voltage of the bus in kV.\nvm_pu::Float64 = 1.0: Voltage magnitude of the bus in per unit (default is 1.0).\nva_deg::Float64 = 0.0: Voltage angle of the bus in degrees (default is 0.0).\nvmin_pu::Union{Nothing,Float64} = nothing: Minimum voltage limit in per unit (default is network's vmin_pu).\nvmax_pu::Union{Nothing,Float64} = nothing: Maximum voltage limit in per unit (default is network's vmax_pu).\nisAux::Bool = false: Boolean indicating if the bus is auxiliary (default is false).\noBusIdx::Union{Nothing,Int} = nothing: Original bus index (default is nothing).\nzone::Union{Nothing,Int} = nothing: Zone index (default is nothing).\narea::Union{Nothing,Int} = nothing: Area index (default is nothing).\nratedS::Union{Nothing,Float64} = nothing: Rated power of the bus in MVA (default is nothing).\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.addPIModellTrafo!-Tuple{}","page":"Netowrks Module","title":"Sparlectra.addPIModellTrafo!","text":"Add a transformer with PI model to the network.\n\nArguments\n\nnet::Net: The network to which the transformer will be added.\nfromBus::String: The name of the bus where the transformer originates.\ntoBus::String: The name of the bus where the transformer terminates.\nr_pu::Float64: The per-unit resistance of the transformer.\nx_pu::Float64: The per-unit reactance of the transformer.\nb_pu::Float64: The per-unit susceptance of the transformer.\nstatus::Int: The status of the transformer.\nratedU::Union{Nothing, Float64}: Rated voltage of the transformer. Default is nothing.\nratedS::Union{Nothing, Float64}: Rated apparent power of the transformer. Default is nothing.\nratio::Union{Nothing, Float64}: Ratio of the transformer. Default is nothing.\nshift_deg::Union{Nothing, Float64}: Phase shift angle of the transformer. Default is nothing.\nisAux::Bool: Whether the transformer is an auxiliary transformer. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.addProsumer!-Tuple{}","page":"Netowrks Module","title":"Sparlectra.addProsumer!","text":"Add a prosumer (combination of a producer and consumer) to the network.\n\nArguments\n\nnet::Net: The network to which the prosumer will be added.\nbusName::String: The name of the bus where the prosumer is connected.\ntype::String: The type of the prosumer.\np::Union{Nothing, Float64}: Active power produced or consumed. Default is nothing.\nq::Union{Nothing, Float64}: Reactive power produced or consumed. Default is nothing.\npMin::Union{Nothing, Float64}: Minimum active power. Default is nothing.\npMax::Union{Nothing, Float64}: Maximum active power. Default is nothing.\nqMin::Union{Nothing, Float64}: Minimum reactive power. Default is nothing.\nqMax::Union{Nothing, Float64}: Maximum reactive power. Default is nothing.\nreferencePri::Union{Nothing, String}: Reference bus for the prosumer. Default is nothing.\nvm_pu::Union{Nothing, Float64}: Voltage magnitude setpoint. Default is nothing.\nva_deg::Union{Nothing, Float64}: Voltage angle setpoint. Default is nothing.\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.addShunt!-Tuple{}","page":"Netowrks Module","title":"Sparlectra.addShunt!","text":"addShunt!: Adds a shunt to the network.\n\nParameters:\n\nnet::Net: Network object.\nbusName::String: Name of the bus to which the shunt is added.\npShunt::Float64: Active power of the shunt in MW.\nqShunt::Float64: Reactive power of the shunt in MVar.\nin_service::Int = 1: Indicator for shunt's in-service status (default is 1).\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.geNetBusIdx-Tuple{}","page":"Netowrks Module","title":"Sparlectra.geNetBusIdx","text":"geNetBusIdx: Gets the index of a bus in the network.\n\nParameters:\n\nnet::Net: Network object.\nbusName::String: Name of the bus.\n\nReturns:\n\nInt: Index of the bus in the network.\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.getBusType-Tuple{}","page":"Netowrks Module","title":"Sparlectra.getBusType","text":"Get the type of a specific bus in the network.\n\nArguments\n\nnet::Net: The network from which to retrieve the bus type.\nbusName::String: The name of the bus.\n\nReturns\n\nThe type of the specified bus.\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.getNetOrigBusIdx-Tuple{}","page":"Netowrks Module","title":"Sparlectra.getNetOrigBusIdx","text":"getNetOrigBusIdx: Gets the original index of a bus in the network.\n\nParameters:\n\nnet::Net: Network object.\nbusName::String: Name of the bus.\n\nReturns:\n\nInt: Original index of the bus in the network.\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.getTotalLosses-Tuple{}","page":"Netowrks Module","title":"Sparlectra.getTotalLosses","text":"Get the total losses in the network.\n\nArguments\n\nnet::Net: The network from which to retrieve the losses.\n\nReturns\n\nA tuple (pLosses::Float64, qLosses::Float64) containing the total active and reactive power losses in the network.\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.get_bus_vn_kV-Tuple{}","page":"Netowrks Module","title":"Sparlectra.get_bus_vn_kV","text":"Get the voltage magnitude of a specific bus in the network.\n\nArguments\n\nnet::Net: The network from which to retrieve the voltage magnitude.\nbusName::String: The name of the bus.\n\nReturns\n\nThe voltage magnitude of the specified bus.\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.get_vn_kV-Tuple{}","page":"Netowrks Module","title":"Sparlectra.get_vn_kV","text":"Get the voltage magnitude of a specific bus in the network.\n\nArguments\n\nnet::Net: The network from which to retrieve the voltage magnitude.\nbusIdx::Int: The index of the bus.\n\nReturns\n\nThe voltage magnitude of the specified bus.\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.hasBusInNet-Tuple{}","page":"Netowrks Module","title":"Sparlectra.hasBusInNet","text":"hasBusInNet: Checks if a bus exists in the network.\n\nParameters:\n\nnet::Net: Network object.\nbusName::String: Name of the bus to check.\n\nReturns:\n\nBool: True if the bus exists in the network, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.lockNet!-Tuple{}","page":"Netowrks Module","title":"Sparlectra.lockNet!","text":"Lock or unlock the network.\n\nArguments\n\nnet::Net: The network to be locked or unlocked.\nlocked::Bool: Boolean indicating whether to lock the network.\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.setBranchStatus!-Tuple{}","page":"Netowrks Module","title":"Sparlectra.setBranchStatus!","text":"Set the status of a branch in the network.\n\nArguments\n\nnet::Net: The network object.\nfromBus::String: The name of the bus where the branch originates.\ntoBus::String: The name of the bus where the branch terminates.\nstatus::Int: The new status of the branch.\n\nExamples\n\nnet = run_acpflow(max_ite= 7,tol = 1e-6, casefile='a_case.m') # run the power flow on the network and get the network object\nsetBranchStatus!(net, \"Bus1\", \"Bus2\", 1)  # Set the status of the branch from Bus1 to Bus2 to 1.\nrun_net_acpflow(net = net, max_ite= 7,tol = 1e-6) # rerun the power flow with the updated network\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.setTotalLosses!-Tuple{}","page":"Netowrks Module","title":"Sparlectra.setTotalLosses!","text":"Set the total losses in the network.\n\nArguments\n\nnet::Net: The network to which the losses will be added.\npLosses::Float64: Total active power losses.\nqLosses::Float64: Total reactive power losses.\n\n\n\n\n\n","category":"method"},{"location":"networks.html#Sparlectra.validate-Tuple{}","page":"Netowrks Module","title":"Sparlectra.validate","text":"Validate the network configuration.\n\nArguments\n\nnet::Net: The network to be validated.\n\nReturns\n\nA tuple (valid::Bool, message::String) where valid is a boolean indicating whether the network is valid, and message is a string containing an error message if the network is invalid.\n\n\n\n\n\n","category":"method"},{"location":"branchmodel.html#Network-Branch-Model","page":"Network Branch Model","title":"Network Branch Model","text":"","category":"section"},{"location":"branchmodel.html","page":"Network Branch Model","title":"Network Branch Model","text":"Each branch is treated with the same four-terminal network model. It is a four-terminal network with an ideal transformer connected upstream. For power lines, the transmission ratio (N) is set to 1. For transformers, the transformation ratio (N) is given as a complex value. The admittance matrix (Y) looks like this:","category":"page"},{"location":"branchmodel.html","page":"Network Branch Model","title":"Network Branch Model","text":"[ Y{br} = \\begin{bmatrix}     \\frac{1}{{\\tau^2}} \\cdot (ys + j\\frac{bc}{2}) & -ys \\cdot \\frac{1}{{\\tau e^{-j\\phi}}} \\\n    -ys \\cdot \\frac{1}{{\\tau e^{j\\phi}}} & (ys + j\\frac{b_c}{2}) \\end{bmatrix} ]","category":"page"},{"location":"branchmodel.html","page":"Network Branch Model","title":"Network Branch Model","text":"where:","category":"page"},{"location":"branchmodel.html","page":"Network Branch Model","title":"Network Branch Model","text":"( y_s = \\frac{1}{R + jX} ) is the series admittance,\n( R ) is the resistance component, and\n( X ) is the reactance component,\n( b_c ) is the transverse admittance,\n( N = \\tau \\cdot e^{j\\phi}) is a complex transformation factor (eg 1 for power lines)","category":"page"},{"location":"branchmodel.html#Circuit-diagram","page":"Network Branch Model","title":"Circuit diagram","text":"","category":"section"},{"location":"branchmodel.html","page":"Network Branch Model","title":"Network Branch Model","text":"                    ys\n      x--┓┏---------###----------x\n         ||   |             |\n         ||   # jbc/2       # jbc/2\n         ||   |             |\n      x--┛┗----------------------x \n         N (complex number)             \n","category":"page"},{"location":"branchmodel.html","page":"Network Branch Model","title":"Network Branch Model","text":"<!– Dies ist ein auskommentierter Abschnitt –> <!–┏ <! ┣ <! ┗ <! ┓ <! ┃ <! ┛ ( Y_{i0} ) fgfdgdfgfdg –>","category":"page"},{"location":"changelog.html#Change-Log","page":"Change Log","title":"Change Log","text":"","category":"section"},{"location":"changelog.html#Version-0.4.11-(2024-05-01)","page":"Change Log","title":"Version 0.4.11 (2024-05-01)","text":"","category":"section"},{"location":"changelog.html#New-Features","page":"Change Log","title":"New Features","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"make changes to imported Matpower networks after import.","category":"page"},{"location":"changelog.html#Enhancements","page":"Change Log","title":"Enhancements","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"added functions to facilitate the creation of networks\nadded documentation make file","category":"page"},{"location":"changelog.html#Bug-Fixes","page":"Change Log","title":"Bug Fixes","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"import and parser for Matpower .m files","category":"page"},{"location":"changelog.html#Version-0.4.10-(2024-05-01)","page":"Change Log","title":"Version 0.4.10 (2024-05-01)","text":"","category":"section"},{"location":"changelog.html#New-Features-2","page":"Change Log","title":"New Features","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"removed numerous redundant functions, partially restructured classes\nremoved support for CGMES due to the availability of numerous alternative libraries\nremoved support for the legacy custom JSON data format (potentially subject to reintroduction at a later stage)","category":"page"},{"location":"changelog.html#Enhancements-2","page":"Change Log","title":"Enhancements","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"added functions to facilitate the creation of networks\nbetter performance","category":"page"},{"location":"changelog.html#Bug-Fixes-2","page":"Change Log","title":"Bug Fixes","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"calculation of branch flow and losses\nbranches out of service","category":"page"},{"location":"changelog.html#Version-0.4.8-(2024-03-26)","page":"Change Log","title":"Version 0.4.8 (2024-03-26)","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"first package release registered in the Julia registry","category":"page"},{"location":"changelog.html#Version-0.4.1-(2023-12-19)","page":"Change Log","title":"Version 0.4.1 (2023-12-19)","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"Initial release of Sparlectra","category":"page"},{"location":"changelog.html#Version-0.4.0-(2023-11-30)","page":"Change Log","title":"Version 0.4.0 (2023-11-30)","text":"","category":"section"},{"location":"changelog.html","page":"Change Log","title":"Change Log","text":"Initial public commit of Sparlectra ","category":"page"},{"location":"import.html#Import-and-Export-Netowrks-Module","page":"Import and Export Netowrks Module","title":"Import and Export Netowrks Module","text":"","category":"section"},{"location":"import.html#Importing-a-Matpower-Network-Configuration","page":"Import and Export Netowrks Module","title":"Importing a Matpower Network Configuration","text":"","category":"section"},{"location":"import.html","page":"Import and Export Netowrks Module","title":"Import and Export Netowrks Module","text":"This example demonstrates how to import a network configuration from a Matpower case file and run a power flow analysis on it. The casefile is located in the data directory of the package. The run_acpflow function is used to run the power flow analysis.","category":"page"},{"location":"import.html#Example","page":"Import and Export Netowrks Module","title":"Example","text":"","category":"section"},{"location":"import.html","page":"Import and Export Netowrks Module","title":"Import and Export Netowrks Module","text":"using Sparlectra\nusing Logging\n\nfile = \"case3.m\"\ntol = 1e-8\nite = 10\nverbose = 0 # 0: no output, 1: iteration norm, 2: + Y-Bus, 3: + Jacobian, 4: + Power Flow\n\n# Call acpflow function with input parameters and measure execution time\nrun_acpflow(max_ite= ite,tol = tol, casefile=file)","category":"page"},{"location":"import.html","page":"Import and Export Netowrks Module","title":"Import and Export Netowrks Module","text":"!!! Note      Please note that providing support for individualized network data issues is beyond the scope of this project, as it is not maintained by an organization. Users are encouraged to take initiative in resolving such issues independently and sharing their results with the community.","category":"page"},{"location":"import.html","page":"Import and Export Netowrks Module","title":"Import and Export Netowrks Module","text":"  Modules = [Sparlectra]   \n  Pages = [\"import.jl\",\"createnet_powermat.jl\", \"exportMatPower.jl\",\"run_acpflow.jl\"]\n  Order = [:type, :function]","category":"page"},{"location":"import.html#Sparlectra.createNetFromMatPowerFile","page":"Import and Export Netowrks Module","title":"Sparlectra.createNetFromMatPowerFile","text":"Creates a network from a MatPower case file.\n\nArguments\n\nfilename: Path to the MatPower case file.\nlog::Bool = false: Whether to log information (default: false).\n\nReturns\n\nA Net object representing the network.\n\n\n\n\n\n","category":"function"},{"location":"import.html#Sparlectra.writeMatpowerCasefile-Tuple{Net, String}","page":"Import and Export Netowrks Module","title":"Sparlectra.writeMatpowerCasefile","text":"writeMatpowerCasefile(net::Net, pathfilename::String)\n\nWrite Matpower case files.\n\nArguments\n\nnet::Net: Network object.\npathfilename::String: Path and filename to write the Matpower case file.\n\nExample\n\nnet = Net(...)\nwriteMatpowerCasefile(net, \"casefile.m\")\n\n\n\n\n\n","category":"method"},{"location":"import.html#Sparlectra.run_acpflow-Tuple{}","page":"Import and Export Netowrks Module","title":"Sparlectra.run_acpflow","text":"Function to perform AC power flow analysis.\n\nParameters:\n\nmax_ite: Int, the maximum number of iterations for the power flow algorithm (default: 10).\ntol: Float64, tolerance for convergence criterion (default: 1e-6).\ncasefile: String, the name of the case file to load.\npath: Union{Nothing,String}, the path to the case file (default: nothing).\nverbose: Int, verbosity level for output (default: 0).\nprintResultToFile: Bool, flag to print results to a file (default: false).\nprintResultAnyCase: Bool, flag to print results even if the power flow fails (default: false).\n\nReturns:\n\nNet, the network object.\n\n\n\n\n\n","category":"method"},{"location":"import.html#Sparlectra.run_net_acpflow-Tuple{}","page":"Import and Export Netowrks Module","title":"Sparlectra.run_net_acpflow","text":"Function to perform AC power flow analysis.\n\nParameters:\n\nnet: Net, the network object.\nmax_ite: Int, the maximum number of iterations for the power flow algorithm (default: 10).\ntol: Float64, tolerance for convergence criterion (default: 1e-6).\nverbose: Int, verbosity level for output (default: 0).\nprintResultToFile: Bool, flag to print results to a file (default: false).\nprintResultAnyCase: Bool, flag to print results even if the power flow fails (default: false).\n\n\n\n\n\n","category":"method"},{"location":"reference.html#Function-Reference","page":"Function Reference","title":"Function Reference","text":"","category":"section"},{"location":"reference.html","page":"Function Reference","title":"Function Reference","text":"  Modules = [Sparlectra] \n  Order = [:function, :type]  \n  Pages = [\"equicircuit.jl\", \"jacobian.jl\"]","category":"page"},{"location":"reference.html#Sparlectra.adjacentBranches","page":"Function Reference","title":"Sparlectra.adjacentBranches","text":"adjacentBranches: Find adjacent branches for each node in the network.\n\nParameters:\n\nY::AbstractMatrix{ComplexF64}: Admittance matrix of the network.\nlog::Bool = false: Optional parameter indicating whether to print the adjacent branches (default is false).\n\nReturns:\n\nadjList::Vector{Vector{Int}}: Vector of vectors containing the indices of adjacent branches for each node.\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Sparlectra.createYBUS","page":"Function Reference","title":"Sparlectra.createYBUS","text":"createYBUS: Create the admittance matrix YBUS from the branch vector and the slack index.\n\nParameters:\n\nbranchVec::Vector{Branch}: Vector of branch objects representing the network branches.\nshuntVec::Vector{Shunt}: Vector of shunt objects representing shunt elements in the network.\nsparse::Bool = true: Optional parameter indicating whether to create a sparse YBUS matrix (default is true).\nprintYBUS::Bool = false: Optional parameter indicating whether to print the YBUS matrix (default is false).\n\nReturns:\n\nY::SparseMatrixCSC{ComplexF64} or Array{ComplexF64}: The YBUS admittance matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Sparlectra.runpf!","page":"Function Reference","title":"Sparlectra.runpf!","text":"Runs the power flow calculation using the Newton-Raphson method.\n\nArguments\n\nnet::Net: Network data structure.\nmaxIte::Int: Maximum number of iterations.\ntolerance::Float64 = 1e-6: Tolerance for convergence (default: 1e-6).\nverbose::Int = 0: Verbosity level (default: 0).\n\nReturns\n\nA tuple containing the number of iterations and the result of the calculation:\n\n0: Convergence reached.\n1: No convergence.\n2: Unsolvable system of equations.\n3: Error.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Sparlectra","page":"Sparlectra","title":"Sparlectra","text":"","category":"section"},{"location":"index.html","page":"Sparlectra","title":"Sparlectra","text":"Sparlectra is a Julia package for the simulation of electrical power systems. It primarily features a program for calculating load flow using the Newton-Raphson method. The focus is to provide valuable insights into load flow calculations for both students and ambitious professionals. The package supports the import and export of Matpower .m files, although currently it only reads bus, generator, and branch data from these files. Please note that additional Matlab functions within the .m file are not supported. Additionally, you can create your own network using easy-to-use functions provided by the package.","category":"page"},{"location":"index.html","page":"Sparlectra","title":"Sparlectra","text":"","category":"page"},{"location":"index.html#Installation","page":"Sparlectra","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Sparlectra","title":"Sparlectra","text":"For installation, run the following command in the Julia REPL:","category":"page"},{"location":"index.html","page":"Sparlectra","title":"Sparlectra","text":"import Pkg\nPkg.add(\"Sparlectra\")","category":"page"},{"location":"index.html","page":"Sparlectra","title":"Sparlectra","text":"","category":"page"},{"location":"index.html#Contributors","page":"Sparlectra","title":"Contributors","text":"","category":"section"},{"location":"index.html","page":"Sparlectra","title":"Sparlectra","text":"Udo Schmitz - Electrical Engineer","category":"page"}]
}
